package constructorast;

import java_cup.runtime.*;
import alex.AnalizadorLexicoExp;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErroresExp;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresExp errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresExp();
   AnalizadorLexicoExp alex = (AnalizadorLexicoExp)getScanner(); 
   alex.fijaGestionErrores(errores);
:};


terminal BOOL, IF, IFELSE, ELSE, WHILE, FUN, CALL, RETURN, STRUCT, LLEVA, 
         IDEN, ENT, REAL, 
         SUMA, RESTA, MUL, DIV, MOD, POT, AND, OR, MAYOR, MENOR, OPIGUAL,
         PAP, PCIERRE, CAP, CCIERRE, LAP, LCIERRE,
         PUNTOCOMA, IGUAL, COMA;

terminal TokenValue INT;

non terminal  E Exp, Term, Fact;

Exp ::= Exp: aDeexp1 SUMA Term: aDeterm 
   {: RESULT= new EBin(KindE.SUMA,aDeexp1,aDeterm); :};
Exp ::= Term: aDeterm
   {: RESULT=aDeterm; :};
   
Term ::= Term: aDeterm1 MUL Fact: aDefact
   {: RESULT= new EBin(KindE.MUL,aDeterm1,aDefact); :};
Term ::= Term: aDeterm1 DIV Fact: aDefact
   {: RESULT= new EBin(KindE.DIV,aDeterm1,aDefact); :};
Term ::= Term: aDeterm1 POT Fact: aDefact
   {: RESULT= new EBin(KindE.POT,aDeterm1,aDefact); :};
Term ::= Term: aDeterm1 MOD Fact: aDefact
   {: RESULT= new EBin(KindE.MOD,aDeterm1,aDefact); :};
Term ::= Fact: aDefact
   {: RESULT=aDefact; :};  

Fact ::= INT: intValue           
   {: RESULT = new Int(intValue.lexema); :};
Fact ::= PAP Exp: aDeexp PCIERRE
   {: RESULT = aDeexp; :};


