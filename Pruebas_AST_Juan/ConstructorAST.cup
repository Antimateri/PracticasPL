package constructorast;

import java_cup.runtime.*;
import alex.AnalizadorLexicoExp;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErroresExp;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresExp errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresExp();
   AnalizadorLexicoExp alex = (AnalizadorLexicoExp)getScanner(); 
   alex.fijaGestionErrores(errores);
:};


terminal IF, WHILE, ASIG, IFELSE, ELSE,
         SUMA, RESTA, MUL, DIV, MOD, POT, AND, OR, MAYOR, MENOR, OPIGUAL,
         PAP, PCIERRE, CAP, CCIERRE, LAP, LCIERRE,
         PUNTOCOMA, IGUAL, COMA;

terminal TokenValue INT, IDEN;

non terminal  Statement S, Linea, Bloque, Instr, Exp, Op0, Op1, Op2;
               


Bloque ::= Linea: l1 Bloque: b1 
   {: RESULT= new InsBin(KindI.BLOQUE,l1,b1); :};
Bloque ::= Linea: l1
   {: RESULT=l1; :};

Linea ::= Instr: i1
   {: RESULT=i1; :};
Linea ::= Exp: e1 PUNTOCOMA
   {: RESULT=e1; :};

Instr ::= IF PAP Exp: e2 PCIERRE LAP Bloque: b2 LCIERRE
   {: RESULT= new InsBin(KindI.IF,e2,b2); :};
Instr ::= WHILE PAP Exp: e2 PCIERRE LAP Bloque: b2 LCIERRE
   {: RESULT= new InsBin(KindI.WHILE,e2,b2); :};
Instr ::= Exp: e1 IGUAL Exp: e2 PUNTOCOMA
   {: RESULT= new InsBin(KindI.ASIG,e1,e2); :};
Instr ::= IFELSE PAP Exp: e2 PCIERRE LAP Bloque: b2 LCIERRE ELSE LAP Bloque: b3 LCIERRE
   {: RESULT= new InsTer(KindI.IFELSE,e2,b2,b3); :};

Exp ::= Exp: aDeexp1 SUMA Op0: aDeterm 
   {: RESULT= new EBin(KindE.SUMA,aDeexp1,aDeterm); :};
Exp ::= Exp: aDeexp1 RESTA Op0: aDeterm 
   {: RESULT= new EBin(KindE.RESTA,aDeexp1,aDeterm); :};
Exp ::= Op0: aDeterm
   {: RESULT=aDeterm; :};
   
Op0 ::= Op0: aDeterm1 MUL Op1: aDefact
   {: RESULT= new EBin(KindE.MUL,aDeterm1,aDefact); :};
Op0 ::= Op0: aDeterm1 DIV Op1: aDefact
   {: RESULT= new EBin(KindE.DIV,aDeterm1,aDefact); :};
Op0 ::= Op1: aDeterm2
   {: RESULT=aDeterm2; :};

Op1 ::= Op1: aDeterm1 POT Op2: aDefact
   {: RESULT= new EBin(KindE.POT,aDeterm1,aDefact); :};
Op1 ::= Op1: aDeterm1 MOD Op2: aDefact
   {: RESULT= new EBin(KindE.MOD,aDeterm1,aDefact); :};
Op1 ::= Op2: aDefact
   {: RESULT=aDefact; :};

Op2 ::= INT: intValue           
   {: RESULT = new Int(intValue.lexema); :};
Op2 ::= PAP Exp: aDeexp PCIERRE
   {: RESULT = aDeexp; :};

