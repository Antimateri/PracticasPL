package constructorast;

import java_cup.runtime.*;
import java.util.ArrayList;
import alex.AnalizadorLexicoExp;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErroresExp;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresExp errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresExp();
   AnalizadorLexicoExp alex = (AnalizadorLexicoExp)getScanner(); 
   alex.fijaGestionErrores(errores);
:};


terminal IF, WHILE, ASIG, IFELSE, ELSE,
         SUMA, RESTA, MUL, DIV, MOD, POT, AND, OR, MAYOR, MENOR, OPIGUAL,
         PAP, PCIERRE, CAP, CCIERRE, LAP, LCIERRE,
         PUNTOCOMA, IGUAL, COMA,
         TIPOINT, TIPOBOOL;

terminal TokenValue INT, IDEN;

non terminal  Statement Linea, Instr, Exp, Op0, Op1, Op2, Op3, Op4, Tipo, Dec, Ident;
non terminal  Bloque Bl;


Bl ::= Bl: b1 Linea: l1 
   {: b1.append(l1);
      RESULT= b1; :};
Bl ::= Linea: l1
   {: RESULT=new Bloque(l1); :};

Linea ::= Instr: i1
   {: RESULT=i1; :};
Linea ::= Dec: d1 PUNTOCOMA
   {: RESULT=d1; :};
Linea ::= Exp: e1 PUNTOCOMA
   {: RESULT=e1; :};

Instr ::= IF PAP Exp: e2 PCIERRE LAP Bl: b2 LCIERRE
   {: ArrayList<Statement> array = new ArrayList<Statement>();
      array.add(e2); array.add(b2);
      RESULT= new InsBin(KindI.IF,array); :};
Instr ::= WHILE PAP Exp: e2 PCIERRE LAP Bl: b2 LCIERRE
   {: ArrayList<Statement> array = new ArrayList<Statement>();
      array.add(e2); array.add(b2); 
      RESULT= new InsBin(KindI.WHILE,array); :};
Instr ::= Ident: id1 IGUAL Exp: e2 PUNTOCOMA
   {: ArrayList<Statement> array = new ArrayList<Statement>();
      array.add(id1); array.add(e2);
      RESULT= new InsBin(KindI.ASIG,array); :};
Instr ::= IFELSE PAP Exp: e2 PCIERRE LAP Bl: b2 LCIERRE ELSE LAP Bl: b3 LCIERRE
   {: ArrayList<Statement> array = new ArrayList<Statement>();
      array.add(e2); array.add(b2); array.add(b3);
      RESULT= new InsBin(KindI.IFELSE,array); :};

Exp ::= Exp: aDeexp1 SUMA Op0: aDeterm 
   {: RESULT= new EBin(KindE.SUMA,aDeexp1,aDeterm); :};
Exp ::= Exp: aDeexp1 RESTA Op0: aDeterm 
   {: RESULT= new EBin(KindE.RESTA,aDeexp1,aDeterm); :};
Exp ::= Op0: aDeterm
   {: RESULT=aDeterm; :};
   
Op0 ::= Op0: aDeterm1 MUL Op1: aDefact
   {: RESULT= new EBin(KindE.MUL,aDeterm1,aDefact); :};
Op0 ::= Op0: aDeterm1 DIV Op1: aDefact
   {: RESULT= new EBin(KindE.DIV,aDeterm1,aDefact); :};
Op0 ::= Op1: aDeterm2
   {: RESULT=aDeterm2; :};

Op1 ::= Op1: aDeterm1 POT Op2: aDefact
   {: RESULT= new EBin(KindE.POT,aDeterm1,aDefact); :};
Op1 ::= Op1: aDeterm1 MOD Op2: aDefact
   {: RESULT= new EBin(KindE.MOD,aDeterm1,aDefact); :};
Op1 ::= Op2: aDefact
   {: RESULT=aDefact; :};

Op2 ::= Op2: aDeterm1 AND Op3: aDefact
   {: RESULT= new EBin(KindE.AND,aDeterm1,aDefact); :};
Op2 ::= Op2: aDeterm1 OR Op3: aDefact
   {: RESULT= new EBin(KindE.OR,aDeterm1,aDefact); :};
Op2 ::= Op3: aDefact
   {: RESULT=aDefact; :};

Op3 ::= Op3: aDeterm1 MAYOR Op4: aDefact
   {: RESULT= new EBin(KindE.MAY,aDeterm1,aDefact); :};
Op3 ::= Op3: aDeterm1 MENOR Op4: aDefact
   {: RESULT= new EBin(KindE.MEN,aDeterm1,aDefact); :};
Op3 ::= Op3: aDeterm1 OPIGUAL Op4: aDefact
   {: RESULT= new EBin(KindE.EQ,aDeterm1,aDefact); :};
Op3 ::= Op4: aDefact
   {: RESULT=aDefact; :};

Op4 ::= INT: intValue           
   {: RESULT = new Int(intValue.lexema); :};
Op4 ::= Ident: id          
   {: RESULT = id; :};
Op4 ::= PAP Exp: aDeexp PCIERRE
   {: RESULT = aDeexp; :};

Tipo ::= TIPOINT
   {: RESULT = new TSimple(KindT.INT); :};
Tipo ::= TIPOBOOL
   {: RESULT = new TSimple(KindT.BOOL); :};

Ident ::= IDEN: idValue
   {: RESULT = new Iden(idValue.lexema); :};

Dec ::= Tipo: t1 Ident: id
   {: ArrayList<Statement> array = new ArrayList<Statement>();
      array.add(t1); array.add(id);
      RESULT= new Dec(KindD.VAR, array); :};